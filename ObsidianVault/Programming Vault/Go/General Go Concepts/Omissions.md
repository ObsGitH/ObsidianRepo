WIKIPEDIA

Go deliberately omits certain features common in other languages, including [(implementation) inheritance](https://en.wikipedia.org/wiki/Inheritance_(object-oriented_programming) "Inheritance (object-oriented programming)"), [assertions](https://en.wikipedia.org/wiki/Assertion_(software_development) "Assertion (software development)"),[[f]](https://en.wikipedia.org/wiki/Go_(programming_language)#cite_note-117) [pointer arithmetic](https://en.wikipedia.org/wiki/Pointer_arithmetic "Pointer arithmetic"),[[e]](https://en.wikipedia.org/wiki/Go_(programming_language)#cite_note-noPointerArith-67) [implicit type conversions](https://en.wikipedia.org/wiki/Type_conversion#Implicit_type_conversion "Type conversion"), [untagged unions](https://en.wikipedia.org/wiki/Untagged_union "Untagged union"),[[g]](https://en.wikipedia.org/wiki/Go_(programming_language)#cite_note-118) and [tagged unions](https://en.wikipedia.org/wiki/Tagged_union "Tagged union").[[h]](https://en.wikipedia.org/wiki/Go_(programming_language)#cite_note-121) The designers added only those facilities that all three agreed on.[[114]](https://en.wikipedia.org/wiki/Go_(programming_language)#cite_note-122)

Of the omitted language features, the designers explicitly argue against assertions and pointer arithmetic, while defending the choice to omit type inheritance as giving a more useful language, encouraging instead the use of [interfaces](https://en.wikipedia.org/wiki/Protocol_(object-oriented_programming) "Protocol (object-oriented programming)") to achieve [dynamic dispatch](https://en.wikipedia.org/wiki/Dynamic_dispatch "Dynamic dispatch")[[i]](https://en.wikipedia.org/wiki/Go_(programming_language)#cite_note-123) and [composition](https://en.wikipedia.org/wiki/Composition_over_inheritance "Composition over inheritance") to reuse code. Composition and [delegation](https://en.wikipedia.org/wiki/Delegation_(programming) "Delegation (programming)") are in fact largely automated by struct embedding; according to researchers Schmager _et al._, this feature "has many of the drawbacks of inheritance: it affects the public interface of objects, it is not fine-grained (i.e, no method-level control over embedding), methods of embedded objects cannot be hidden, and it is static", making it "not obvious" whether programmers will overuse it to the extent that programmers in other languages are reputed to overuse inheritance.[[70]](https://en.wikipedia.org/wiki/Go_(programming_language)#cite_note-gohotdraw-75)

[Exception handling](https://en.wikipedia.org/wiki/Exception_handling "Exception handling") was initially omitted in Go due to lack of a "design that gives value proportionate to the complexity".[[115]](https://en.wikipedia.org/wiki/Go_(programming_language)#cite_note-124) An exception-like panic/recover mechanism that avoids the usual `try-catch` control structure was proposed[[116]](https://en.wikipedia.org/wiki/Go_(programming_language)#cite_note-125) and released in the March 30, 2010 snapshot.[[117]](https://en.wikipedia.org/wiki/Go_(programming_language)#cite_note-126) The Go authors advise using it for unrecoverable errors such as those that should halt an entire program or server request, or as a shortcut to propagate errors up the stack within a package.[[118]](https://en.wikipedia.org/wiki/Go_(programming_language)#cite_note-127)[[119]](https://en.wikipedia.org/wiki/Go_(programming_language)#cite_note-128) Across package boundaries, Go includes a canonical error type, and multi-value returns using this type are the standard idiom.[[4]](https://en.wikipedia.org/wiki/Go_(programming_language)#cite_note-langfaq-4)